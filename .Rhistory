matrix.for.numbers = as.matrix(numbers.to.check)
#Turning into vector
vector.of.numbers.to.check = c(matrix.for.numbers)
#Removing the squares
x = 1:100
y = x^2
vector.of.numbers.to.check = vector.of.numbers.to.check[-y]
vector.of.numbers.to.check = sort(vector.of.numbers.to.check)
#Adding the original problem
original.numbers = c(6 , 10 , 14 , 15 , 21,
22 , 26 , 33 , 34 , 35,
38 , 39 , 46 , 51 , 55,
57 , 58 , 62 , 65 , 69,
75 , 77 , 82 , 85 , 86,
87 , 91 , 93 , 94 , 95)
#Finding the one that does not belong
original.numbers[-which(original.numbers %in% vector.of.numbers.to.check)]
#Finding the one to add back in
vector.of.numbers.to.check = vector.of.numbers.to.check[which(vector.of.numbers.to.check < 100)]
vector.of.numbers.to.check[-which(vector.of.numbers.to.check %in% original.numbers)]
vector.of.numbers.to.check
# All the possible prime numbers
prime.numbers <- 2:100
# Outer loop to find all numbers from 2 to 100
for (i in 1:100) {
# Inner loop to check if it can go evenly into each number by numbers smaller than itself
for (x in 2:(i-1)) {#Loop through everything smaller than i
# If it can be divided by things that are smaller than it than it is not prime so we get rid of everything that can do that
prime.numbers = prime.numbers[prime.numbers != i | i %% x != 0]
#Only doesn't add 2??
}
}
#Adding 2
prime.numbers = c(prime.numbers, 2)
prime.numbers = sort(prime.numbers)
#Making all the values we need to check into a dataframe
numbers.to.check = outer(prime.numbers,prime.numbers, FUN = "*")
#Making into matrix to turn into a vector
matrix.for.numbers = as.matrix(numbers.to.check)
#Turning into vector
vector.of.numbers.to.check = c(matrix.for.numbers)
#Removing the squares and duplicates
unique(vector.of.numbers.to.check)
x = 1:100
y = x^2
vector.of.numbers.to.check = vector.of.numbers.to.check[-y]
vector.of.numbers.to.check = sort(vector.of.numbers.to.check)
#Adding the original problem
original.numbers = c(6 , 10 , 14 , 15 , 21,
22 , 26 , 33 , 34 , 35,
38 , 39 , 46 , 51 , 55,
57 , 58 , 62 , 65 , 69,
75 , 77 , 82 , 85 , 86,
87 , 91 , 93 , 94 , 95)
#Finding the one that does not belong
original.numbers[-which(original.numbers %in% vector.of.numbers.to.check)]
#Finding the one to add back in
vector.of.numbers.to.check = vector.of.numbers.to.check[which(vector.of.numbers.to.check < 100)]
vector.of.numbers.to.check[-which(vector.of.numbers.to.check %in% original.numbers)]
# All the possible prime numbers
prime.numbers <- 2:100
# Outer loop to find all numbers from 2 to 100
for (i in 1:100) {
# Inner loop to check if it can go evenly into each number by numbers smaller than itself
for (x in 2:(i-1)) {#Loop through everything smaller than i
# If it can be divided by things that are smaller than it than it is not prime so we get rid of everything that can do that
prime.numbers = prime.numbers[prime.numbers != i | i %% x != 0]
#Only doesn't add 2??
}
}
#Adding 2
prime.numbers = c(prime.numbers, 2)
prime.numbers = sort(prime.numbers)
#Making all the values we need to check into a dataframe
numbers.to.check = outer(prime.numbers,prime.numbers, FUN = "*")
#Making into matrix to turn into a vector
matrix.for.numbers = as.matrix(numbers.to.check)
#Turning into vector
vector.of.numbers.to.check = c(matrix.for.numbers)
#Removing the squares and duplicates
vector.of.numbers.to.check = unique(vector.of.numbers.to.check)
x = 1:100
y = x^2
vector.of.numbers.to.check = vector.of.numbers.to.check[-y]
vector.of.numbers.to.check = sort(vector.of.numbers.to.check)
#Adding the original problem
original.numbers = c(6 , 10 , 14 , 15 , 21,
22 , 26 , 33 , 34 , 35,
38 , 39 , 46 , 51 , 55,
57 , 58 , 62 , 65 , 69,
75 , 77 , 82 , 85 , 86,
87 , 91 , 93 , 94 , 95)
#Finding the one that does not belong
original.numbers[-which(original.numbers %in% vector.of.numbers.to.check)]
#Finding the one to add back in
vector.of.numbers.to.check = vector.of.numbers.to.check[which(vector.of.numbers.to.check < 100)]
vector.of.numbers.to.check[-which(vector.of.numbers.to.check %in% original.numbers)]
# All the possible prime numbers
prime.numbers <- 2:100
# Outer loop to find all numbers from 2 to 100
for (i in 1:100) {
# Inner loop to check if it can go evenly into each number by numbers smaller than itself
for (x in 2:(i-1)) {#Loop through everything smaller than i
# If it can be divided by things that are smaller than it than it is not prime so we get rid of everything that can do that
prime.numbers = prime.numbers[prime.numbers != i | i %% x != 0]
#Only doesn't add 2??
}
}
#Adding 2
prime.numbers = c(prime.numbers, 2)
prime.numbers = sort(prime.numbers)
#Making all the values we need to check into a dataframe
numbers.to.check = outer(prime.numbers,prime.numbers, FUN = "*")
#Making into matrix to turn into a vector
matrix.for.numbers = as.matrix(numbers.to.check)
#Turning into vector
vector.of.numbers.to.check = c(matrix.for.numbers)
#Removing the squares and duplicates
vector.of.numbers.to.check = unique(vector.of.numbers.to.check)
x = 1:100
y = x^2
vector.of.numbers.to.check = vector.of.numbers.to.check[-y]
vector.of.numbers.to.check = sort(vector.of.numbers.to.check)
#Adding the original problem
original.numbers = c(6 , 10 , 14 , 15 , 21,
22 , 26 , 33 , 34 , 35,
38 , 39 , 46 , 51 , 55,
57 , 58 , 62 , 65 , 69,
75 , 77 , 82 , 85 , 86,
87 , 91 , 93 , 94 , 95)
#Finding the one that does not belong
original.numbers[-which(original.numbers %in% vector.of.numbers.to.check)]
#Finding the one to add back in
vector.of.numbers.to.check = vector.of.numbers.to.check[which(vector.of.numbers.to.check < 100)]
vector.of.numbers.to.check[-which(vector.of.numbers.to.check %in% original.numbers)]
# All the possible prime numbers
prime.numbers <- 2:100
# Outer loop to find all numbers from 2 to 100
for (i in 1:100) {
# Inner loop to check if it can go evenly into each number by numbers smaller than itself
for (x in 2:(i-1)) {#Loop through everything smaller than i
# If it can be divided by things that are smaller than it than it is not prime so we get rid of everything that can do that
prime.numbers = prime.numbers[prime.numbers != i | i %% x != 0]
#Only doesn't add 2??
}
}
#Adding 2
prime.numbers = c(prime.numbers, 2)
prime.numbers = sort(prime.numbers)
#Making all the values we need to check into a dataframe
numbers.to.check = outer(prime.numbers,prime.numbers, FUN = "*")
#Making into matrix to turn into a vector
matrix.for.numbers = as.matrix(numbers.to.check)
#Turning into vector
vector.of.numbers.to.check = c(matrix.for.numbers)
#Removing the squares and duplicates
vector.of.numbers.to.check = unique(vector.of.numbers.to.check)
x = 1:100
y = x^2
vector.of.numbers.to.check = vector.of.numbers.to.check[-y]
vector.of.numbers.to.check = sort(vector.of.numbers.to.check)
#Adding the original problem
original.numbers = c(6 , 10 , 14 , 15 , 21,
22 , 26 , 33 , 34 , 35,
38 , 39 , 46 , 51 , 55,
57 , 58 , 62 , 65 , 69,
75 , 77 , 82 , 85 , 86,
87 , 91 , 93 , 94 , 95)
#Finding the one that does not belong
original.numbers[-which(original.numbers %in% vector.of.numbers.to.check)]
#Finding the one to add back in
vector.of.numbers.to.check = vector.of.numbers.to.check[which(vector.of.numbers.to.check < 100)]
vector.of.numbers.to.check[-which(vector.of.numbers.to.check %in% original.numbers)]
vector.of.numbers.to.check
# All the possible prime numbers
prime.numbers <- 2:100
# Outer loop to find all numbers from 2 to 100
for (i in 1:100) {
# Inner loop to check if it can go evenly into each number by numbers smaller than itself
for (x in 2:(i-1)) {#Loop through everything smaller than i
# If it can be divided by things that are smaller than it than it is not prime so we get rid of everything that can do that
prime.numbers = prime.numbers[prime.numbers != i | i %% x != 0]
#Only doesn't add 2??
}
}
#Adding 2
prime.numbers = c(prime.numbers, 2)
prime.numbers = sort(prime.numbers)
#Making all the values we need to check into a dataframe
numbers.to.check = outer(prime.numbers,prime.numbers, FUN = "*")
#Making into matrix to turn into a vector
matrix.for.numbers = as.matrix(numbers.to.check)
#Turning into vector
vector.of.numbers.to.check = c(matrix.for.numbers)
#Removing the squares and duplicates
vector.of.numbers.to.check = unique(vector.of.numbers.to.check)
vector.of.numbers.to.check
# All the possible prime numbers
prime.numbers <- 2:100
# Outer loop to find all numbers from 2 to 100
for (i in 1:100) {
# Inner loop to check if it can go evenly into each number by numbers smaller than itself
for (x in 2:(i-1)) {#Loop through everything smaller than i
# If it can be divided by things that are smaller than it than it is not prime so we get rid of everything that can do that
prime.numbers = prime.numbers[prime.numbers != i | i %% x != 0]
#Only doesn't add 2??
}
}
#Adding 2
prime.numbers = c(prime.numbers, 2)
prime.numbers = sort(prime.numbers)
#Making all the values we need to check into a dataframe
numbers.to.check = outer(prime.numbers,prime.numbers, FUN = "*")
#Making into matrix to turn into a vector
matrix.for.numbers = as.matrix(numbers.to.check)
#Turning into vector
vector.of.numbers.to.check = c(matrix.for.numbers)
#Removing the squares and duplicates
vector.of.numbers.to.check = unique(vector.of.numbers.to.check)
x = 1:100
y = x^2
vector.of.numbers.to.check = vector.of.numbers.to.check[-which(vector.of.numbers.to.check == y)]
vector.of.numbers.to.check = sort(vector.of.numbers.to.check)
#Adding the original problem
original.numbers = c(6 , 10 , 14 , 15 , 21,
22 , 26 , 33 , 34 , 35,
38 , 39 , 46 , 51 , 55,
57 , 58 , 62 , 65 , 69,
75 , 77 , 82 , 85 , 86,
87 , 91 , 93 , 94 , 95)
#Finding the one that does not belong
original.numbers[-which(original.numbers %in% vector.of.numbers.to.check)]
#Finding the one to add back in
vector.of.numbers.to.check = vector.of.numbers.to.check[which(vector.of.numbers.to.check < 100)]
vector.of.numbers.to.check[-which(vector.of.numbers.to.check %in% original.numbers)]
# All the possible prime numbers
prime.numbers <- 2:100
# Outer loop to find all numbers from 2 to 100
for (i in 1:100) {
# Inner loop to check if it can go evenly into each number by numbers smaller than itself
for (x in 2:(i-1)) {#Loop through everything smaller than i
# If it can be divided by things that are smaller than it than it is not prime so we get rid of everything that can do that
prime.numbers = prime.numbers[prime.numbers != i | i %% x != 0]
#Only doesn't add 2??
}
}
#Adding 2
prime.numbers = c(prime.numbers, 2)
prime.numbers = sort(prime.numbers)
#Making all the values we need to check into a dataframe
numbers.to.check = outer(prime.numbers,prime.numbers, FUN = "*")
#Making into matrix to turn into a vector
matrix.for.numbers = as.matrix(numbers.to.check)
#Turning into vector
vector.of.numbers.to.check = c(matrix.for.numbers)
#Removing the squares and duplicates
vector.of.numbers.to.check = unique(vector.of.numbers.to.check)
x = 1:100
y = x^2
vector.of.numbers.to.check = vector.of.numbers.to.check[-which(vector.of.numbers.to.check %in% y)]
vector.of.numbers.to.check = sort(vector.of.numbers.to.check)
#Adding the original problem
original.numbers = c(6 , 10 , 14 , 15 , 21,
22 , 26 , 33 , 34 , 35,
38 , 39 , 46 , 51 , 55,
57 , 58 , 62 , 65 , 69,
75 , 77 , 82 , 85 , 86,
87 , 91 , 93 , 94 , 95)
#Finding the one that does not belong
original.numbers[-which(original.numbers %in% vector.of.numbers.to.check)]
#Finding the one to add back in
vector.of.numbers.to.check = vector.of.numbers.to.check[which(vector.of.numbers.to.check < 100)]
vector.of.numbers.to.check[-which(vector.of.numbers.to.check %in% original.numbers)]
\documentclass{article}
for(i in 1:100){
for(x in 1:100){
num.to.check = prime.numbers[i]prime.numbers[x]
for(i in 1:100){
for(x in 1:100){
num.to.check = prime.numbers[i]prime.numbers[x]
for(i in 1:100){
for(x in 1:100){
num.to.check = prime.numbers[i]*prime.numbers[x]
}
}
for(i in 1:length(prime.numbers)){
for(x in 1:length(prime.numbers)){
num.to.check = prime.numbers[i]*prime.numbers[x]
}
}
for(i in 1:length(prime.numbers)){
for(x in 1:length(prime.numbers)){
num.to.check[i] = prime.numbers[i]*prime.numbers[x]
}
}
for(i in 1:length(prime.numbers)){
for(x in 1:length(prime.numbers)){
num.to.check[i] = prime.numbers[i]*prime.numbers[x]
}
}
num.to.check = sort(num.to.check)
num.to.check
for(i in 1:length(prime.numbers)){
for(x in 1:length(prime.numbers)){
for(j in 1:length(prime.numbers)){}
num.to.check[j] = prime.numbers[i]*prime.numbers[x]
}
}
}
prime.numbers[1]*prime.numbers[2]
num.to.check=c()
for(i in 1:length(prime.numbers)){
for(x in 1:length(prime.numbers)){
for(j in 1:2*length(prime.numbers)){}
num.to.check[j] = prime.numbers[i]*prime.numbers[x]
}
}
}
num.to.check=c()
for(i in 1:length(prime.numbers)){
for(x in 1:length(prime.numbers)){
for(j in 1:2*length(prime.numbers)){
num.to.check[j] = prime.numbers[i]*prime.numbers[x]
}
}
}
for(i in 1:length(prime.numbers)){
for(x in 1:length(prime.numbers)){
num.to.check = c(num.to.check, prime.numbers[i]*prime.numbers[x])
}
}
num.to.check=c()
for(i in 1:length(prime.numbers)){
for(x in 1:length(prime.numbers)){
num.to.check = c(num.to.check, prime.numbers[i]*prime.numbers[x])
}
}
num.to.check = sort(num.to.check)
# All the possible prime numbers
prime.numbers <- 2:100
# Outer loop to find all numbers from 2 to 100
for (i in 1:100) {
# Inner loop to check if it can go evenly into each number by numbers smaller than itself
for (x in 2:(i-1)) {#Loop through everything smaller than i
# If it can be divided by things that are smaller than it than it is not prime so we get rid of everything that can do that
prime.numbers = prime.numbers[prime.numbers != i | i %% x != 0]
#Only doesn't add 2??
}
}
#Adding 2
prime.numbers = c(prime.numbers, 2)
prime.numbers = sort(prime.numbers)
#Making the products into a vector
num.to.check=c()
for(i in 1:length(prime.numbers)){
for(x in 1:length(prime.numbers)){
num.to.check = c(num.to.check, prime.numbers[i]*prime.numbers[x])
}
}
num.to.check = sort(num.to.check)
#Removing the squares and duplicates
num.to.check = unique(num.to.check)
x = 1:100
y = x^2
num.to.check = num.to.check[-which(num.to.check %in% y)]
num.to.check = sort(num.to.check)
#Adding the original problem
original.numbers = c(6 , 10 , 14 , 15 , 21,
22 , 26 , 33 , 34 , 35,
38 , 39 , 46 , 51 , 55,
57 , 58 , 62 , 65 , 69,
75 , 77 , 82 , 85 , 86,
87 , 91 , 93 , 94 , 95)
#Finding the one that does not belong
original.numbers[-which(original.numbers %in% num.to.check)]
#Finding the one to add back in
num.to.check = num.to.check[which(num.to.check < 100)] #Sorting below 100
num.to.check[-which(num.to.check %in% original.numbers)]
prime.numbers <- 2:100
# Outer loop to find all numbers from 2 to 100
for (i in 1:100) {
# Inner loop to check if it can go evenly into each number by numbers smaller than itself
for (x in 2:(i-1)) {#Loop through everything smaller than i
# If it can be divided by things that are smaller than it than it is not prime so we get rid of everything that can do that
prime.numbers = prime.numbers[i %% x != 0]
#Only doesn't add 2??
}
}
# All the possible prime numbers
prime.numbers <- 2:100
prime.numbers <- c(2, 3, 4, )
# All the possible prime numbers
prime.numbers <- 2:100
# Outer loop to find all numbers from 2 to 100
for (i in 1:100) {
# Inner loop to check if it can go evenly into each number by numbers smaller than itself
for (x in 2:min(2,(i-1))) {#Loop through everything smaller than i
# If it can be divided by things that are smaller than it than it is not prime so we get rid of everything that can do that
prime.numbers = prime.numbers[prime.numbers != i | i %% x != 0]
#Only doesn't add 2??
}
}
#Adding 2
prime.numbers
# All the possible prime numbers
prime.numbers <- 2:100
# Outer loop to find all numbers from 2 to 100
for (i in 1:100) {
# Inner loop to check if it can go evenly into each number by numbers smaller than itself
for (x in 2:(i-1)) {#Loop through everything smaller than i
# If it can be divided by things that are smaller than it than it is not prime so we get rid of everything that can do that
prime.numbers = prime.numbers[prime.numbers != i | i %% x != 0]
#Only doesn't add 2??
}
}
#Adding 2
prime.numbers
# All the possible prime numbers
prime.numbers <- 2:100
# Outer loop to find all numbers from 2 to 100
for (i in 1:100) {
# Inner loop to check if it can go evenly into each number by numbers smaller than itself
for (x in 2:(i-1)) {#Loop through everything smaller than i
# If it can be divided by things that are smaller than it than it is not prime so we get rid of everything that can do that
prime.numbers = prime.numbers[prime.numbers != i | i %% x != 0]
#Only doesn't add 2??
}
}
#Adding 2
prime.numbers
2:0
#install.packages("stringr")
#install.packages("jsonlite")
library(stringr)
library(jsonlite)
current.filename = c("The Front Bottoms-Talon Of The Hawk-Au Revoir (Adios).json")
(name.without.json = str_sub(current.filename, start = 1, nchar(current.filename) - 5))
#Setting Song, Artist, album
(artist = str_split_i(name.without.json, "-", 1))
(album = str_split_i(name.without.json, "-", 2))
(track = str_split_i(name.without.json, "-", 3))
#Pulling JSON Data
essentia.output = paste("EssentiaOutput", current.filename, sep = "/")
(jsondata = fromJSON(essentia.output))
#install.packages("stringr")
#install.packages("jsonlite")
library(stringr)
library(jsonlite)
current.filename = c("The Front Bottoms-Talon Of The Hawk-Au Revoir (Adios).json")
(name.without.json = str_sub(current.filename, start = 1, nchar(current.filename) - 5))
#Setting Song, Artist, album
(artist = str_split_i(name.without.json, "-", 1))
(album = str_split_i(name.without.json, "-", 2))
(track = str_split_i(name.without.json, "-", 3))
#Pulling JSON Data
essentia.output = paste("EssentiaOutput", current.filename, sep = "/")
(jsondata = fromJSON(essentia.output))
(jsondata = fromJSON(essentia.output))
essentia.output = paste("EssentiaOutput", current.filename, sep = "/")
(jsondata = fromJSON(essentia.output))
current.filename
essentia.output
#install.packages("stringr")
#install.packages("jsonlite")
library(stringr)
library(jsonlite)
current.filename = c("The Front Bottoms-Talon Of The Hawk-Au Revoir (Adios).json")
(name.without.json = str_sub(current.filename, start = 1, nchar(current.filename) - 5))
#Setting Song, Artist, album
(artist = str_split_i(name.without.json, "-", 1))
(album = str_split_i(name.without.json, "-", 2))
(track = str_split_i(name.without.json, "-", 3))
#Pulling JSON Data
essentia.output = paste("EssentiaOutput", current.filename, sep = "/")
(jsondata = fromJSON(essentia.output))
library(stringr)
library(jsonlite)
current.filename = c("The Front Bottoms-Talon Of The Hawk-Au Revoir (Adios).json")
name.with.json = list.files("EssentiaOutput")
#Making empty vectors
overall_loudness = c()
spectral_energy = c()
dissonance = c()
pitch_salience = c()
bpm = c()
beats_loudness = c()
danceability = c()
tuning_frequency = c()
name.without.json = c()
artist = c()
album = c()
track = c()
#Putting everything as vectors and filling them in
for(i in 1:length(list.files("EssentiaOutput"))){
current.filename = list.files("EssentiaOutput")[i]
(name.without.json[i] = str_sub(current.filename, start = 1, nchar(current.filename) - 5))
#Setting Song, Artist, album
(artist[i] = str_split_i(name.without.json[i], "-", 1))
(album[i] = str_split_i(name.without.json[i], "-", 2))
(track[i] = str_split_i(name.without.json[i], "-", 3))
#Pulling JSON Data
essentia.output = paste("EssentiaOutput", current.filename, sep = "/")
(jsondata = fromJSON(essentia.output))
overall_loudness[i] = jsondata$lowlevel$loudness_ebu128$integrated
spectral_energy[i] = jsondata$lowlevel$spectral_energy$mean
dissonance[i] = jsondata$lowlevel$dissonance$mean
pitch_salience[i] = jsondata$lowlevel$pitch_salience$mean
bpm[i] = jsondata$rhythm$bpm
beats_loudness[i] = jsondata$rhythm$beats_loudness$mean
danceability[i] = jsondata$rhythm$danceability
tuning_frequency[i] = jsondata$tonal$tuning_frequency
}
